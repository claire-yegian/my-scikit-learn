##############################################
# Programmer: Claire Yegian
# 12/11/22
# Description: Fits and prints rules for an association rule miner.
##############################################
import itertools
from tabulate import tabulate

from mysklearn import myutils

class MyAssociationRuleMiner:
    """Represents an association rule miner.
    Attributes:
        minsup(float): The minimum support value to use when computing supported itemsets
        minconf(float): The minimum confidence value to use when generating rules
        X_train(list of list of obj): The list of training instances (samples)
                The shape of X_train is (n_train_samples, n_features)
        rules(list of dict): The generated rules
    Notes:
        Implements the apriori algorithm
        Terminology: instance = sample = row and attribute = feature = column
    """
    def __init__(self, minsup=0.25, minconf=0.8):
        """Initializer for MyAssociationRuleMiner.
        Args:
            minsup(float): The minimum support value to use when computing supported itemsets
                (0.25 if a value is not provided and the default minsup should be used)
            minconf(float): The minimum confidence value to use when generating rules
                (0.8 if a value is not provided and the default minconf should be used)
        """
        self.minsup = minsup
        self.minconf = minconf
        self.X_train = None
        self.rules = None

    def generate_apriori_rules(self, supported_itemsets):
        """Finds supported and confident rules from the itemsets generated by the apriori
        algorithm
        Args:
            supported_itemsets(set of frozensets): The supported itemsets generated
                by the apriori algorithm
        Returns:
            (list of dicts): all confident rules in dictionary format where "lhs"
                key's value is the left-hand side of the rule and the "rhs" key's
                value is the right-hand side.
        """
        rules = []
        supported_itemsets = [sorted(itemset) for itemset in supported_itemsets]
        for itemset in supported_itemsets:
            powerset = []
            for i in range(len(itemset) + 1):
                powerset.extend(itertools.combinations(itemset, i))
            for item in powerset:
                item = sorted(item)
                if len(item) != 0 and len(item) != len(itemset):
                    not_included = []
                    for element in itemset:
                        if element not in item:
                            not_included.append(element)
                    rule = {"lhs": item, "rhs": not_included}
                    if rule not in rules:
                        Nleft, _, Nboth, _ = myutils.compute_rule_counts(rule, self.X_train)
                        if Nboth/Nleft >= self.minconf:
                            rules.append(rule)
        return rules 

    def apriori(self):
        """Runs apriori algorithm to generate rules
        Returns:
            (set of frozensets): all supported itemsets found by the algorithm
        """
        supported_itemsets = set()
        initial_itemsets = myutils.compute_unique_values(self.X_train)
        initial_itemsets = set(frozenset([item]) for item in initial_itemsets)
        initial_itemsets = myutils.find_supported_itemsets(initial_itemsets, self.X_train, self.minsup)
        current_L = set(frozenset(itemset) for itemset in initial_itemsets)
        k = 2
        while len(current_L) != 0:
            new_L = set()
            candidate_set = myutils.compute_joined_candidates(current_L)
            for c_set in candidate_set:
                subsets = itertools.combinations(c_set, k-1)
                member = True
                for subset in subsets:
                    subset = frozenset(subset)
                    if subset not in current_L:
                        member = False
                if member:
                    new_L.add(c_set)
            new_L = myutils.find_supported_itemsets(new_L, self.X_train, self.minsup)
            for s_set in new_L:
                supported_itemsets.add(s_set)
            k += 1
            current_L = new_L
        rules = self.generate_apriori_rules(supported_itemsets)
        return rules 

    def fit(self, X_train):
        """Fits an association rule miner to X_train using the Apriori algorithm.
        Args:
            X_train(list of list of obj): The list of training instances (samples)
                The shape of X_train is (n_train_samples, n_features)
        Notes:
            Store the list of generated association rules in the rules attribute
            If X_train represents a non-market basket analysis dataset, then:
                Attribute labels should be prepended to attribute values in X_train
                    before fit() is called (e.g. "att=val", ...).
                Make sure a rule does not include the same attribute more than once
        """
        self.X_train = X_train
        self.rules = self.apriori()
        self.apriori()

    def print_association_rules(self):
        """Prints the association rules in the format "IF val AND ... THEN val AND...", one rule on each line.
        Notes:
            Each rule's output should include an identifying number, the rule, the rule's support,
            the rule's confidence, and the rule's lift
            Consider using the tabulate library to help with this: https://pypi.org/project/tabulate/
        """
        header = ["#", "association rule", "support", "confidence", "lift"]
        table = []
        i = 1
        for rule in self.rules:
            string = "IF "
            Nleft, Nright, Nboth, Ntotal = myutils.compute_rule_counts(rule, self.X_train)
            for left_element in rule["lhs"]:
                string += left_element + " AND "
            string = string[:-4]
            string += "THEN "
            for right_element in rule["rhs"]:
                string += right_element + " AND "
            string = string[:-5]
            table.append([i, string, Nboth/Ntotal, Nboth/Nleft, Nboth/(Nleft * Nright/Ntotal)])
            i += 1
        print(tabulate(table, headers=header))
